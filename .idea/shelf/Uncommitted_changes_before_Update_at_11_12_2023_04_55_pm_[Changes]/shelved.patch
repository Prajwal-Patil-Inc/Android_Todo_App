Index: app/src/main/java/com/example/myapplication/screens/TodoScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.myapplication.screens\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.graphics.ImageDecoder\r\nimport android.util.Log\r\nimport androidx.compose.foundation.clickable\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Column\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.layout.size\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.foundation.shape.CornerSize\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.foundation.text.KeyboardOptions\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Add\r\nimport androidx.compose.material.icons.filled.Check\r\nimport androidx.compose.material.icons.filled.DateRange\r\nimport androidx.compose.material.icons.filled.Delete\r\nimport androidx.compose.material.icons.filled.Edit\r\nimport androidx.compose.material.icons.filled.Favorite\r\nimport androidx.compose.material.icons.filled.Info\r\nimport androidx.compose.material.icons.outlined.FavoriteBorder\r\nimport androidx.compose.material.icons.outlined.Info\r\nimport androidx.compose.material3.Button\r\nimport androidx.compose.material3.Card\r\nimport androidx.compose.material3.CardDefaults\r\nimport androidx.compose.material3.Checkbox\r\nimport androidx.compose.material3.DatePicker\r\nimport androidx.compose.material3.DatePickerDialog\r\nimport androidx.compose.material3.DisplayMode\r\nimport androidx.compose.material3.Divider\r\nimport androidx.compose.material3.DropdownMenu\r\nimport androidx.compose.material3.DropdownMenuItem\r\nimport androidx.compose.material3.ExperimentalMaterial3Api\r\nimport androidx.compose.material3.ExposedDropdownMenuBox\r\nimport androidx.compose.material3.ExposedDropdownMenuDefaults\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.IconButton\r\nimport androidx.compose.material3.OutlinedTextField\r\nimport androidx.compose.material3.SnackbarHostState\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TextButton\r\nimport androidx.compose.material3.TextField\r\nimport androidx.compose.material3.TimePicker\r\nimport androidx.compose.material3.rememberDatePickerState\r\nimport androidx.compose.material3.rememberTimePickerState\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.collectAsState\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableStateOf\r\nimport androidx.compose.runtime.remember\r\nimport androidx.compose.runtime.rememberCoroutineScope\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.text.SpanStyle\r\nimport androidx.compose.ui.text.buildAnnotatedString\r\nimport androidx.compose.ui.text.font.FontWeight\r\nimport androidx.compose.ui.text.input.ImeAction\r\nimport androidx.compose.ui.text.style.TextDecoration\r\nimport androidx.compose.ui.text.withStyle\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.unit.sp\r\nimport androidx.lifecycle.viewmodel.compose.viewModel\r\nimport com.example.myapplication.TodoCategories\r\nimport com.example.myapplication.todoDatabase.TodoDatabase\r\nimport com.example.myapplication.todoEntities.SubtaskTodo\r\nimport com.example.myapplication.todoEntities.Todo\r\nimport com.example.myapplication.todoViewModels.SubtaskTodoViewModel\r\nimport com.example.myapplication.todoViewModels.TodoViewModel\r\nimport com.example.myapplication.ui.theme.Priority\r\nimport com.example.myapplication.ui.theme.PriorityTodosData\r\nimport kotlinx.coroutines.flow.Flow\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.selects.select\r\nimport java.text.SimpleDateFormat\r\nimport java.util.Calendar\r\nimport java.util.Collections\r\nimport java.util.Locale\r\nimport androidx.compose.material.icons.filled.AccessTime\r\nimport androidx.compose.material.icons.filled.CalendarToday\r\nimport android.net.Uri\r\nimport androidx.compose.foundation.Image\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.ui.graphics.asImageBitmap\r\n\r\n\r\nvar toBeDeletedRows = hashSetOf<Long>()\r\n\r\n\r\n@SuppressLint(\"UnusedMaterial3ScaffoldPaddingParameter\")\r\n@Composable\r\nfun TodoDetail(selectedCategory: TodoCategories?, onNavigate: (Long) -> Unit){\r\n    val todoViewModel: TodoViewModel = viewModel()\r\n    val subtaskTodoViewModel: SubtaskTodoViewModel = viewModel()\r\nLazyColumn(\r\n        modifier = Modifier\r\n            .padding(5.dp)\r\n            .fillMaxSize())\r\n         {item{\r\n             if(todoViewModel.isEmpty()){\r\n                 Text(text = (\"No Todos\"))\r\n             }\r\n             else{\r\n                 if(selectedCategory?.todoCategories == \"Today\"){\r\n                     if(subtaskTodoViewModel.isEmpty()){\r\n                         Todos(todo = todoViewModel.currentDateTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks, todoViewModel){\r\n                                 todoId -> onNavigate(todoId)\r\n                         }\r\n                     }\r\n                     else{\r\n                         Todos(todo = todoViewModel.currentDateTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks, todoViewModel){\r\n                                 todoId -> onNavigate(todoId)\r\n                         }\r\n                     }\r\n                     //This function needs to be moved to fun Todos to make it global for every todo\r\n                     //Currently this is just visible for Today category todos\r\n                     TodoDeleteIcon()\r\n                     Log.i(\"cat\", \"Todayyyyyyyyyy\")\r\n                 }\r\n                 if(selectedCategory?.todoCategories == \"All\"){\r\n                     Todos(todo = todoViewModel.allTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks, todoViewModel){\r\n                             todoId -> onNavigate(todoId)\r\n                     }\r\n                     TodoDeleteIcon()\r\n                     Log.i(\"cat\", \"ALLLLLLLLL\")\r\n                 }\r\n                 if(selectedCategory?.todoCategories == \"Scheduled\"){\r\n                     if(todoViewModel.isScheduledEmpty()){\r\n                         Text(text = \"No Scheduled todos\")\r\n                     }\r\n                     else{\r\n                         Todos(todo = todoViewModel.scheduledTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks ,todoViewModel){\r\n                                 todoId -> onNavigate(todoId)\r\n                         }\r\n                     }\r\n                     TodoDeleteIcon()\r\n                     Log.i(\"cat\", \"Scheduled\")\r\n                 }\r\n                 if(selectedCategory?.todoCategories == \"Important\"){\r\n                     if(todoViewModel.isImportantEmpty()){\r\n                         Text(text = \"No Important todos\")\r\n                     }\r\n                     else{\r\n                         Todos(todo = todoViewModel.importantTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks, viewModel = todoViewModel){\r\n                                 todoId -> onNavigate(todoId)\r\n                         }\r\n                     }\r\n                     TodoDeleteIcon()\r\n                     Log.i(\"cat\", \"Important\")\r\n                 }\r\n                 if(selectedCategory?.todoCategories == \"Finished\"){\r\n                     if(todoViewModel.isFinishedEmpty()){\r\n                         Text(text = \"No Finished Todos here\")\r\n                     }\r\n                     Todos(todo = todoViewModel.finishedTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks, viewModel = todoViewModel){\r\n                             todoId -> onNavigate(todoId)\r\n                     }\r\n\r\n                     Log.i(\"cat\", \"Finished\")\r\n                 }\r\n                 if(selectedCategory?.todoCategories == \"Bin\"){\r\n                     Todos(todo = todoViewModel.todosInBin, subtaskTodo = subtaskTodoViewModel.allSubtasks, viewModel = todoViewModel){\r\n                             todoId -> onNavigate(todoId)\r\n                     }\r\n                     DeleteIcon()\r\n                     Log.i(\"cat\", \"Bin\")\r\n                 }\r\n             }\r\n        }\r\n     }\r\n}\r\n\r\n@Composable\r\nfun TodoDeleteIcon(){\r\n    val buttonCoroutineScope = rememberCoroutineScope()\r\n    val dao = TodoDatabase.getDatabase(LocalContext.current).todoDao()\r\n    fun clickToDelete(){\r\n        toBeDeletedRows.iterator().forEach { element->\r\n            buttonCoroutineScope.launch {\r\n\r\n                dao.delete(\r\n                    element\r\n                )\r\n            }\r\n        }\r\n    }\r\n    IconButton(onClick = {\r\n        clickToDelete()\r\n    }) {\r\n        Icon(Icons.Default.Delete, contentDescription =\"Delete\" )\r\n    }\r\n}\r\n\r\n@Composable\r\nfun DeleteIcon(){\r\n    val buttonCoroutineScope = rememberCoroutineScope()\r\n    val dao = TodoDatabase.getDatabase(LocalContext.current).todoDao()\r\n    fun clickToDelete(){\r\n        toBeDeletedRows.iterator().forEach { element->\r\n            buttonCoroutineScope.launch {\r\n\r\n                dao.deleteFromBin(\r\n                    element\r\n                )\r\n            }\r\n        }\r\n    }\r\n    IconButton(onClick = {\r\n        clickToDelete()\r\n    }) {\r\n        Icon(Icons.Default.Delete, contentDescription =\"Delete\" )\r\n    }\r\n}\r\n\r\nfun myCustomComparator() = Comparator<Todo>{ a, b ->\r\n    when {\r\n        (a.priority == b.priority) -> 0\r\n        (a.priority == Priority.HIGH && b.priority == Priority.STANDARD) -> -1\r\n        (a.priority == Priority.HIGH && b.priority == Priority.LOW) -> -1\r\n        else -> 1\r\n    }\r\n}\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun Todos(todo: Flow<List<Todo>>, subtaskTodo: Flow<List<SubtaskTodo>>, viewModel: TodoViewModel, onNavigate: (todoId: Long) -> Unit) {\r\n    val todosState by todo.collectAsState(initial = emptyList())\r\n    val subtaskTodoState by subtaskTodo.collectAsState(initial = emptyList())\r\n\r\n    Collections.sort(todosState, myCustomComparator())\r\n\r\n//    IconButton(onClick = {Log.d(\"Extra\",\"onclick is working\")} ) {\r\n//        Text(text = \"Hello\")\r\n//    }\r\n    Column {\r\n        todosState.forEach { todoItem ->\r\n            var isExpanded by remember { mutableStateOf(false) }\r\n            val isChecked = remember { mutableStateOf(todoItem.isFinished) }\r\n            val coroutineScope = rememberCoroutineScope()\r\n            val textDecoration = if (isChecked.value) TextDecoration.LineThrough else null\r\n            var isFavClicked by remember { mutableStateOf(todoItem.isFavorite) }\r\n            var isImportantClicked by remember { mutableStateOf(todoItem.isImportant) }\r\n            var editingTitle by remember { mutableStateOf(todoItem.title) }\r\n            var subtask by remember { mutableStateOf(false) }\r\n            var editingDescription by remember { mutableStateOf(todoItem.description) }\r\n            var isEditing  by remember { mutableStateOf(false) }\r\n            val context = LocalContext.current\r\n\r\n            var isEditingDate by remember { mutableStateOf(false) }\r\n            var isEditingTime by remember { mutableStateOf(false) }\r\n            val editDatePickerState = rememberDatePickerState(initialDisplayMode = DisplayMode.Input)\r\n            val editTimePickerState = rememberTimePickerState()\r\n            val snackScope = rememberCoroutineScope()\r\n            val editTimeFormatter = remember { SimpleDateFormat(\"hh:mm a\", Locale.getDefault()) }\r\n            val snackState = remember{ SnackbarHostState() }\r\n            var editedScheduledDate by remember { mutableStateOf(\"null\") }\r\n            var editedScheduledTime by remember { mutableStateOf(\"null\") }\r\n\r\n            val favIcon = if (isFavClicked) {\r\n                Icons.Filled.Favorite\r\n            } else {\r\n                Icons.Outlined.FavoriteBorder\r\n            }\r\n            val impIcon = if (isImportantClicked) {\r\n                Icons.Filled.Info\r\n            } else {\r\n                Icons.Outlined.Info\r\n            }\r\n            var dropDownPriorityExpanded by remember { mutableStateOf(false) }\r\n            var selectedPriority by remember{ mutableStateOf(todoItem.priority) }\r\n            Card(\r\n                modifier = Modifier\r\n                    .padding(horizontal = 8.dp, vertical = 8.dp)\r\n                    .fillMaxWidth()\r\n                    .clickable(onClick = { isExpanded = !isExpanded }),\r\n                shape = RoundedCornerShape(CornerSize(10.dp)),\r\n                elevation = CardDefaults.cardElevation(2.dp)\r\n            ) {\r\n                Column(\r\n                    modifier = Modifier.padding(bottom = 10.dp),\r\n                    verticalArrangement = Arrangement.SpaceBetween,\r\n                    horizontalAlignment = Alignment.CenterHorizontally\r\n                ) {\r\n                    Row(\r\n                        modifier = Modifier.padding(5.dp),\r\n                        horizontalArrangement = Arrangement.SpaceBetween,\r\n                        verticalAlignment = Alignment.CenterVertically\r\n                    ) {\r\n                        Checkbox(checked = isChecked.value, onCheckedChange = {\r\n                            isChecked.value = it\r\n\r\n                        })\r\n\r\n                        if (isChecked.value) {\r\n                            toBeDeletedRows.add(todoItem.id)\r\n                            Log.d(\"AA\", \" \"+isChecked.value)\r\n//                            coroutineScope.launch {\r\n//                                viewModel.setFinished(todoItem.id, isChecked.value)\r\n//                            }\r\n                        } else {\r\n//                            Log.d(\"TAG\", \" \"+todoItem.id + \" \")\r\n                            if (toBeDeletedRows.contains(todoItem.id))\r\n                                toBeDeletedRows.remove(todoItem.id)\r\n\r\n                        }\r\n                        if(todoItem.isFinished != isChecked.value) {\r\n//                            Log.d(\"Debug\", \" Entered the if loop \"+isChecked.value)\r\n                            viewModel.setFinished(todoItem.id, isChecked.value)\r\n                        }\r\n\r\n                        if(isEditing){\r\n                            OutlinedTextField(\r\n                                value = editingTitle,\r\n                                onValueChange = {\r\n                                    editingTitle = it\r\n                                },\r\n                                label = { Text(\"Title\") },\r\n                                keyboardOptions = KeyboardOptions.Default.copy(\r\n                                    imeAction = ImeAction.Done\r\n                                ),\r\n                                modifier = Modifier\r\n                                    .fillMaxWidth(0.9f)\r\n                            )\r\n\r\n                        }else{\r\n                        Text(\r\n                            modifier = Modifier.fillMaxWidth(0.9f),\r\n                            text = buildAnnotatedString {\r\n                                withStyle(style = SpanStyle(textDecoration = textDecoration)) {\r\n                                    append(todoItem.title)\r\n                                }\r\n                            },\r\n                            fontSize = 20.sp,\r\n                            fontWeight = FontWeight.Bold\r\n                        )}\r\n\r\n\r\n                        if (isFavClicked) {\r\n                            var isFavClicked by remember { mutableStateOf(todoItem.isFavorite) }\r\n                            val favIcon = if (isFavClicked) {\r\n                                Icons.Filled.Favorite\r\n                            } else {\r\n                                Icons.Outlined.FavoriteBorder\r\n                            }\r\n                            Icon(\r\n                                imageVector = favIcon,\r\n                                contentDescription = \"Already Favorite\",\r\n                                modifier = Modifier.clickable {\r\n                                    isFavClicked = !isFavClicked\r\n                                    coroutineScope.launch {\r\n                                        viewModel.setFavourite(todoItem.id, isFavClicked)\r\n                                    }\r\n                                }\r\n                            )\r\n                        } else {\r\n                            Icon(\r\n                                imageVector = favIcon,\r\n                                contentDescription = \"Not Favorite\",\r\n                                modifier = Modifier.clickable {\r\n                                    isFavClicked = !isFavClicked\r\n                                }\r\n                            )\r\n                        }\r\n                    }\r\n                    Row(\r\n                        modifier = Modifier\r\n                            .padding(5.dp),\r\n                        horizontalArrangement = Arrangement.SpaceBetween,\r\n                        verticalAlignment = Alignment.CenterVertically\r\n                    ) {\r\n                        Column(\r\n                            modifier = Modifier\r\n                                .padding(5.dp)\r\n                                .fillMaxWidth(0.9f),\r\n                            verticalArrangement = Arrangement.SpaceBetween,\r\n                            horizontalAlignment = Alignment.Start\r\n                        ) {\r\n                            if(isEditing){\r\n                                OutlinedTextField(\r\n                                    value = editingDescription,\r\n                                    onValueChange = { editingDescription = it },\r\n                                    label = { Text(\"Description\") },\r\n                                    keyboardOptions = KeyboardOptions.Default.copy(\r\n                                        imeAction = ImeAction.Done\r\n                                    ),\r\n                                    modifier = Modifier\r\n                                        .fillMaxWidth()\r\n                                )\r\n                            }else{\r\n                            Text(\r\n                                text = buildAnnotatedString {\r\n                                    withStyle(style = SpanStyle(textDecoration = textDecoration)) {\r\n                                        append(todoItem.description)\r\n                                    }\r\n                                })}\r\n                            Text(\r\n                                text = buildAnnotatedString {\r\n                                    withStyle(style = SpanStyle(textDecoration = if (isChecked.value) TextDecoration.LineThrough else null)) {\r\n                                        append(todoItem.date)\r\n                                    }\r\n                                }\r\n                            )\r\n                        }\r\n                        if (isImportantClicked) {\r\n                            var isImportantClicked by remember { mutableStateOf(todoItem.isImportant) }\r\n                            val impIcon = if (isImportantClicked) {\r\n                                Icons.Filled.Info\r\n                            } else {\r\n                                Icons.Outlined.Info\r\n                            }\r\n                            Icon(\r\n                                imageVector = impIcon,\r\n                                contentDescription = \"Already Favorite\",\r\n                                modifier = Modifier.clickable {\r\n                                    isImportantClicked = !isImportantClicked\r\n                                    coroutineScope.launch {\r\n                                        viewModel.setImportant(todoItem.id, isImportantClicked)\r\n                                    }\r\n                                }\r\n                            )\r\n                        } else {\r\n                            Icon(\r\n                                imageVector = impIcon,\r\n                                contentDescription = \"Not Favorite\",\r\n                                modifier = Modifier.clickable {\r\n                                    isImportantClicked = !isImportantClicked\r\n                                }\r\n                            )\r\n                        }\r\n                    }\r\n\r\n                    //Expand todo\r\n                    if (isExpanded) {\r\n                        Divider(\r\n                            modifier = Modifier.padding(vertical = 5.dp),\r\n                            thickness = 1.dp,\r\n                        )\r\n                        //Adding priority here\r\n                        if(isEditing){\r\n                            ExposedDropdownMenuBox(\r\n                                expanded = dropDownPriorityExpanded,\r\n                                onExpandedChange = { dropDownPriorityExpanded=!dropDownPriorityExpanded},\r\n                                modifier = Modifier.padding(2.dp)\r\n                            ){\r\n                                TextField(value =\r\n//                                todoItem.priority.toString(),\r\n                                    selectedPriority.toString(),\r\n                                    onValueChange = { },\r\n                                    readOnly = true,\r\n                                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = dropDownPriorityExpanded) },\r\n                                    modifier = Modifier.menuAnchor()\r\n                                )\r\n                                ExposedDropdownMenu(\r\n                                    expanded = dropDownPriorityExpanded,\r\n                                    onDismissRequest = { dropDownPriorityExpanded = false }\r\n                                ) {\r\n                                    PriorityTodosData().forEach { priorityTodos ->\r\n                                        DropdownMenuItem(\r\n                                            text = { Text(priorityTodos.priorityName) },\r\n                                            onClick = {\r\n                                                selectedPriority = priorityTodos.priority\r\n                                                dropDownPriorityExpanded = false\r\n                                            }\r\n                                        )\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else{\r\n                            Row {\r\n                                Text(text = \"Priority: \")\r\n                                Text(text = todoItem.priority.toString())\r\n                            }\r\n                        }\r\n\r\n                        val uriCheck = todoItem.imageUri\r\n                        if(uriCheck != null) {\r\n                            val uri = Uri.parse(todoItem.imageUri)\r\n                            if (uri != null) {\r\n                                val imageBitmap = remember(uri) {\r\n                                    try {\r\n                                        ImageDecoder.decodeBitmap(\r\n                                            ImageDecoder.createSource(context.contentResolver, uri)\r\n                                        ).asImageBitmap()\r\n                                    }catch(e: Exception){\r\n                                        Log.e(\"Exception\", \"$e\")\r\n                                        null\r\n                                    }\r\n                                }\r\n                                imageBitmap?.let{\r\n                                    Image(it, null)\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if(isEditing){\r\n                            Text(\"Edit Scheduled Date: \")\r\n                            IconButton(onClick = {\r\n                                isEditingDate = !isEditingDate\r\n                            }) {\r\n                                Column(\r\n                                    modifier = Modifier\r\n                                        .fillMaxSize()\r\n                                        .size(10.dp),\r\n                                    verticalArrangement = Arrangement.Center,\r\n                                    horizontalAlignment = Alignment.CenterHorizontally\r\n                                ) {\r\n                                    Icon(\r\n                                        Icons.Filled.DateRange, \"Date Picker\"\r\n                                    )\r\n                                    Text(text = \"Date\", fontSize = 8.sp)\r\n                                }\r\n                            }\r\n\r\n                            //Time Picker\r\n                            Text(\"Edit Scheduled Time: \")\r\n                            IconButton(onClick = {\r\n                                isEditingTime = !isEditingTime\r\n                            }) {\r\n                                Column(\r\n                                    modifier = Modifier\r\n                                        .fillMaxSize()\r\n                                        .size(10.dp),\r\n                                    verticalArrangement = Arrangement.Center,\r\n                                    horizontalAlignment = Alignment.CenterHorizontally\r\n                                ) {\r\n                                    Icon(\r\n                                        Icons.Outlined.Info, \"Time Picker\"\r\n                                    )\r\n                                    Text(text = \"Time\", fontSize = 8.sp)\r\n                                }\r\n                            }\r\n\r\n                            if (isEditingDate) {\r\n                                DatePickerDialog(\r\n                                    onDismissRequest = { isEditingDate = false },\r\n                                    confirmButton = {\r\n                                        TextButton(onClick = {\r\n                                            val selectedDateMillis = editDatePickerState.selectedDateMillis\r\n                                            if(selectedDateMillis!=null){\r\n                                                editedScheduledDate = handleSelectedDate(selectedDateMillis)\r\n                                            }\r\n                                            isEditingDate = false\r\n                                            snackScope.launch{\r\n                                                snackState.showSnackbar(\r\n                                                    \"Selected Date: ${editDatePickerState.selectedDateMillis}\"\r\n                                                )\r\n                                            }\r\n                                        }\r\n                                        ) {\r\n                                            Text(text = \"Ok\")\r\n                                        }\r\n                                    },\r\n                                    dismissButton = {\r\n                                        TextButton(\r\n                                            onClick = { isEditingDate = false }\r\n                                        ) {\r\n                                            Text(text = \"Cancel\")\r\n                                        }\r\n                                    }\r\n                                ) {\r\n                                    DatePicker(\r\n                                        state = editDatePickerState,\r\n                                        modifier = Modifier.padding(8.dp)\r\n                                    )\r\n                                }\r\n                            }\r\n                            if (isEditingTime) {\r\n                                TimePickerDialog(\r\n                                    onCancel = { isEditingTime = false },\r\n                                    onConfirm = {\r\n                                        val cal = Calendar.getInstance()\r\n                                        cal.set(Calendar.HOUR_OF_DAY, editTimePickerState.hour)\r\n                                        cal.set(Calendar.MINUTE, editTimePickerState.minute)\r\n                                        cal.isLenient = false\r\n                                        editedScheduledTime = editTimeFormatter.format(cal.time)\r\n                                        snackScope.launch {\r\n                                            snackState.showSnackbar(\"Entered time: ${editTimeFormatter.format(cal.time)}\")\r\n                                        }\r\n                                        isEditingTime = false\r\n                                    }) {\r\n                                    TimePicker(state = editTimePickerState)\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n\r\n                        else {\r\n                            Text(\r\n                                text = buildAnnotatedString {\r\n                                    withStyle(style = SpanStyle(textDecoration = if (isChecked.value) TextDecoration.LineThrough else null)) {\r\n                                        if (todoItem.scheduledDate == \"null\") {\r\n                                            append(\"Scheduled Date: Not scheduled\")\r\n                                        } else {\r\n                                            append(\"Scheduled Date: \" + todoItem.scheduledDate)\r\n                                        }\r\n                                    }\r\n                                })\r\n                            Text(\r\n                                text = buildAnnotatedString {\r\n                                    withStyle(style = SpanStyle(textDecoration = if (isChecked.value) TextDecoration.LineThrough else null)) {\r\n                                        if (todoItem.scheduledTime == \"null\") {\r\n                                            append(\"Scheduled Time: Not scheduled\")\r\n                                        } else {\r\n                                            append(\"Scheduled Time: \" + todoItem.scheduledTime)\r\n                                        }\r\n\r\n                                    }\r\n                                })\r\n                        }\r\n\r\n\r\n\r\n\r\n                        val subtaskTodoViewModel: SubtaskTodoViewModel = viewModel()\r\n                        var subtasksToBeDeleted by remember {mutableStateOf < List<SubtaskTodo>>(emptyList())}\r\n                        //Subtasks\r\n                        if (subtaskTodoState.isEmpty()) {\r\n                            Text(text = \"No subtasks\")\r\n                        } else {\r\n\r\n\r\n                            subtaskTodoState.filter { it.id == todoItem.id }\r\n                                .forEach { subtaskItem ->\r\n                                    var subtaskEditing by remember { mutableStateOf(subtaskItem.subtaskTitle) }\r\n                                    var isSubtaskChecked by remember { mutableStateOf(subtaskItem.isSubtaskCompleted) }\r\n                                    val textDecoration = if (isSubtaskChecked) {\r\n                                        TextDecoration.LineThrough\r\n                                    } else if (isChecked.value) {\r\n                                        TextDecoration.LineThrough\r\n                                    } else {\r\n                                        null\r\n                                    }\r\n\r\n                                    var isEditingSubtaskDate by remember { mutableStateOf(false) }\r\n                                    var isEditingSubtaskTime by remember { mutableStateOf(false) }\r\n                                    val editSubtaskDatePickerState = rememberDatePickerState(initialDisplayMode = DisplayMode.Input)\r\n                                    val editSubtaskTimePickerState = rememberTimePickerState()\r\n                                    val subtaskSnackScope = rememberCoroutineScope()\r\n                                    val editSubtaskTimeFormatter = remember { SimpleDateFormat(\"hh:mm a\", Locale.getDefault()) }\r\n                                    val subtaskSnackState = remember{ SnackbarHostState() }\r\n                                    var editedSubtaskScheduledDate by remember { mutableStateOf(\"null\") }\r\n                                    var editedSubtaskScheduledTime by remember { mutableStateOf(\"null\") }\r\n\r\n                                    //Row\r\n                                    Row(\r\n                                        modifier = Modifier\r\n                                            .padding(5.dp),\r\n                                        horizontalArrangement = Arrangement.SpaceBetween,\r\n                                        verticalAlignment = Alignment.CenterVertically\r\n                                    ) {\r\n                                        if (isSubtaskChecked) {\r\n                                            Checkbox(\r\n                                                checked = isSubtaskChecked,\r\n                                                onCheckedChange = { isSubtaskChecked = !isSubtaskChecked })\r\n                                                if(isSubtaskChecked){\r\n                                                    subtasksToBeDeleted = subtasksToBeDeleted + subtaskItem\r\n                                                }else{\r\n                                                    subtasksToBeDeleted = subtasksToBeDeleted - subtaskItem\r\n                                                }\r\n                                        } else {\r\n                                            Checkbox(\r\n                                                checked = isSubtaskChecked,\r\n                                                onCheckedChange = {\r\n                                                    isSubtaskChecked = it\r\n                                                })\r\n                                        }\r\n                                        if(isEditing){\r\n                                            Column {\r\n                                                OutlinedTextField(\r\n                                                    value = subtaskEditing,\r\n                                                    onValueChange = {\r\n                                                        subtaskEditing = it\r\n                                                    }\r\n                                                )\r\n                                                Row {\r\n                                                    IconButton(onClick = {\r\n                                                        isEditingSubtaskDate = !isEditingSubtaskDate\r\n                                                    }) {\r\n                                                        Column(\r\n                                                            modifier = Modifier\r\n                                                                .fillMaxSize()\r\n                                                                .size(10.dp),\r\n                                                            verticalArrangement = Arrangement.Center,\r\n                                                            horizontalAlignment = Alignment.CenterHorizontally\r\n                                                        ) {\r\n                                                            Icon(\r\n                                                                Icons.Filled.DateRange, \"Date Picker\"\r\n                                                            )\r\n                                                            Text(text = \"Date\", fontSize = 8.sp)\r\n                                                        }\r\n                                                    }\r\n\r\n                                                    //Time Picker\r\n                                                    IconButton(onClick = {\r\n                                                        isEditingSubtaskTime = !isEditingSubtaskTime\r\n                                                    }) {\r\n                                                        Column(\r\n                                                            modifier = Modifier\r\n                                                                .fillMaxSize()\r\n                                                                .size(10.dp),\r\n                                                            verticalArrangement = Arrangement.Center,\r\n                                                            horizontalAlignment = Alignment.CenterHorizontally\r\n                                                        ) {\r\n                                                            Icon(\r\n                                                                Icons.Outlined.Info, \"Time Picker\"\r\n                                                            )\r\n                                                            Text(text = \"Time\", fontSize = 8.sp)\r\n                                                        }\r\n                                                    }\r\n\r\n                                                    if (isEditingSubtaskDate) {\r\n                                                        DatePickerDialog(\r\n                                                            onDismissRequest = { isEditingSubtaskDate = false },\r\n                                                            confirmButton = {\r\n                                                                TextButton(onClick = {\r\n                                                                    val selectedDateMillis = editSubtaskDatePickerState.selectedDateMillis\r\n                                                                    if(selectedDateMillis!=null){\r\n                                                                        editedSubtaskScheduledDate = handleSelectedDate(selectedDateMillis)\r\n                                                                        subtaskItem.subtaskScheduledDate = editedSubtaskScheduledDate\r\n                                                                    }\r\n                                                                    isEditingSubtaskDate = false\r\n                                                                    subtaskSnackScope.launch{\r\n                                                                        subtaskSnackState.showSnackbar(\r\n                                                                            \"Selected Date: ${editSubtaskDatePickerState.selectedDateMillis}\"\r\n                                                                        )\r\n                                                                    }\r\n                                                                }\r\n                                                                ) {\r\n                                                                    Text(text = \"Ok\")\r\n                                                                }\r\n                                                            },\r\n                                                            dismissButton = {\r\n                                                                TextButton(\r\n                                                                    onClick = { isEditingSubtaskDate = false }\r\n                                                                ) {\r\n                                                                    Text(text = \"Cancel\")\r\n                                                                }\r\n                                                            }\r\n                                                        ) {\r\n                                                            DatePicker(\r\n                                                                state = editSubtaskDatePickerState,\r\n                                                                modifier = Modifier.padding(8.dp)\r\n                                                            )\r\n                                                        }\r\n                                                    }\r\n                                                    if (isEditingSubtaskTime) {\r\n                                                        TimePickerDialog(\r\n                                                            onCancel = { isEditingSubtaskTime = false },\r\n                                                            onConfirm = {\r\n                                                                val cal = Calendar.getInstance()\r\n                                                                cal.set(Calendar.HOUR_OF_DAY, editSubtaskTimePickerState.hour)\r\n                                                                cal.set(Calendar.MINUTE, editSubtaskTimePickerState.minute)\r\n                                                                cal.isLenient = false\r\n                                                                editedSubtaskScheduledTime = editSubtaskTimeFormatter.format(cal.time)\r\n                                                                subtaskItem.subtaskScheduledTime = editedSubtaskScheduledTime\r\n                                                                subtaskSnackScope.launch {\r\n                                                                    subtaskSnackState.showSnackbar(\"Entered time: ${editSubtaskTimeFormatter.format(cal.time)}\")\r\n                                                                }\r\n                                                                isEditingSubtaskTime = false\r\n                                                            }) {\r\n                                                            TimePicker(state = editSubtaskTimePickerState)\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }else{\r\n                                        Text(\r\n                                            modifier = Modifier.fillMaxWidth(0.9f),\r\n                                            text = buildAnnotatedString {\r\n                                                withStyle(style = SpanStyle(textDecoration = textDecoration)) {\r\n                                                    append(subtaskItem.subtaskTitle)\r\n                                                    // Add a line break and then append the date and time\r\n                                                    //Date\r\n                                                    if (subtaskItem.subtaskScheduledDate != \"null\") {\r\n                                                        append(\"\\nScheduled Date: \" + subtaskItem.subtaskScheduledDate)\r\n                                                    }\r\n                                                    //Time\r\n                                                    if (subtaskItem.subtaskScheduledTime != \"null\") {\r\n                                                        append(\"\\nScheduled Time: \" + subtaskItem.subtaskScheduledTime)\r\n                                                    }\r\n                                                }\r\n                                            },\r\n                                        )}\r\n                                    }\r\n\r\n                                    //Updating the subtask\r\n                                    if(subtask){\r\n                                        subtaskTodoViewModel.updateSubtaskTodo(\r\n                                        subtaskItem.copy(\r\n                                            subtaskTitle = subtaskEditing,\r\n                                            subtaskScheduledDate = subtaskItem.subtaskScheduledDate,\r\n                                            subtaskScheduledTime = subtaskItem.subtaskScheduledTime\r\n                                         )\r\n                                        )\r\n                                    }\r\n                                }\r\n                        }\r\n\r\n                        //Divider\r\n                        Divider(\r\n                            modifier = Modifier.padding(vertical = 5.dp),\r\n                            thickness = 1.dp,\r\n                        )\r\n                        Row(\r\n                            modifier = Modifier\r\n                                .padding(5.dp)\r\n                                .fillMaxWidth(),\r\n                            horizontalArrangement = Arrangement.SpaceBetween\r\n                        ) {\r\n\r\n                            //Delete Todo Button\r\n                            IconButton(onClick = {\r\n                                subtaskTodoViewModel.deleteSubtaskTodo(subtasksToBeDeleted)\r\n\r\n                            }) {\r\n                                Icon(\r\n                                    imageVector = Icons.Filled.Delete,\r\n                                    contentDescription = \"Edit Todo\"\r\n                                )\r\n                            }\r\n\r\n                            //Add Subtask\r\n                            Column(\r\n                                verticalArrangement = Arrangement.SpaceBetween,\r\n                                horizontalAlignment = Alignment.CenterHorizontally\r\n                            ) {\r\n                                Icon(\r\n                                    modifier = Modifier.clickable(onClick = {\r\n                                        onNavigate(todoItem.id)\r\n                                        Log.i(\"id\", \"${onNavigate(todoItem.id)}\")\r\n                                    }),\r\n                                    imageVector = Icons.Filled.Add,\r\n                                    contentDescription = \"Add Subtask\"\r\n                                )\r\n                                Text(text = \"Add Subtask\")\r\n                            }\r\n                            if(isEditing){\r\n                                Icon(\r\n                                    imageVector = Icons.Filled.Check,\r\n                                    contentDescription = \"Checked\",\r\n                                    modifier = Modifier.clickable {\r\n                                        viewModel.updateTodo(\r\n                                            todoItem.copy(\r\n                                                title = editingTitle,\r\n                                                description = editingDescription,\r\n                                                priority = selectedPriority,\r\n                                                scheduledDate = editedScheduledDate,\r\n                                                scheduledTime = editedScheduledTime\r\n                                            )\r\n                                        )\r\n                                        subtask = true\r\n                                        isEditing = false\r\n                                    }\r\n                                )\r\n                            }else {\r\n                                //Edit Todo Button\r\n                                IconButton(onClick = {\r\n                                    isEditing = true\r\n                                }) {\r\n                                    Icon(\r\n                                        imageVector = Icons.Filled.Edit,\r\n                                        contentDescription = \"Edit Todo\"\r\n                                    )\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\nenum class SortOption {\r\n    DATE, TITLE\r\n}\r\n\r\n@Composable\r\nfun TodoScreen(viewModel: TodoViewModel) {\r\n\r\n    var expanded by remember { mutableStateOf(false) }\r\n    var selectedSortOption by remember { mutableStateOf(SortOption.DATE) }\r\n    var sortedTodos = viewModel.getSortedTodos(selectedSortOption).collectAsState(initial = emptyList())\r\n\r\n    Column(modifier = Modifier.padding(3.dp)) {\r\n        Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.TopEnd){\r\n            Text(text = \"Sort by: ${selectedSortOption.name}\" , modifier = Modifier.clickable { expanded = true })\r\n            DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {\r\n                DropdownMenuItem(text = { \"Date\" }, onClick = {\r\n                    selectedSortOption = SortOption.DATE\r\n                    expanded = false\r\n                })\r\n                DropdownMenuItem(text = { \"Title\" }, onClick = {\r\n                    selectedSortOption = SortOption.TITLE\r\n                    expanded = false\r\n                })\r\n\r\n            }\r\n    }\r\n        // Rest UI, including the sorted todo list\r\n    }\r\n}\r\n\r\n//@Composable\r\n//fun TodoList(todos: List<Todo>) {\r\n//    LazyColumn {\r\n//        items(todos) { todo -> TodoCard(todo)\r\n//        }\r\n//    }\r\n//}\r\n//\r\n//@Composable\r\n//fun TodoCard(todo: Todo) {\r\n//    Card(\r\n//        modifier = Modifier\r\n//            .fillMaxWidth()\r\n//            .padding(3.dp),\r\n//        elevation = 2.dp,\r\n//        shape = RoundedCornerShape(8.dp)\r\n//    ) {\r\n//        Column(modifier = Modifier.padding(16.dp)) {\r\n//            Text(\r\n//                text = todo.title,\r\n//                fontWeight = FontWeight.Bold,\r\n//                fontSize = 18.sp\r\n//            )\r\n//            Spacer(modifier = Modifier.height(8.dp))\r\n//            Text(text = todo.description)\r\n//            Spacer(modifier = Modifier.height(8.dp))\r\n//            Row {\r\n//                IconButton(onClick = { /* TODO: Implement favorite action */ }) {\r\n//                    Icon(\r\n//                        imageVector = if (todo.isFavorite) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,\r\n//                        contentDescription = \"Favorite\"\r\n//                    )\r\n//                }\r\n//                IconButton(onClick = { /* TODO: Implement important action */ }) {\r\n//                    Icon(\r\n//                        imageVector = if (todo.isImportant) Icons.Filled.Info else Icons.Outlined.Info,\r\n//                        contentDescription = \"Important\"\r\n//                    )\r\n//                }\r\n//                // Additional actions can be added here\r\n//            }\r\n//        }\r\n//    }\r\n//}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/myapplication/screens/TodoScreen.kt b/app/src/main/java/com/example/myapplication/screens/TodoScreen.kt
--- a/app/src/main/java/com/example/myapplication/screens/TodoScreen.kt	(revision e4edb1cf4ef2d226e484a9a9995d7c0133a27c8d)
+++ b/app/src/main/java/com/example/myapplication/screens/TodoScreen.kt	(date 1702046249897)
@@ -108,10 +108,8 @@
              }
              else{
                  if(selectedCategory?.todoCategories == "Today"){
-                     if(subtaskTodoViewModel.isEmpty()){
-                         Todos(todo = todoViewModel.currentDateTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks, todoViewModel){
-                                 todoId -> onNavigate(todoId)
-                         }
+                     if(todoViewModel.isTodayEmpty()){
+                         Text("No todos made today")
                      }
                      else{
                          Todos(todo = todoViewModel.currentDateTodos, subtaskTodo = subtaskTodoViewModel.allSubtasks, todoViewModel){
Index: app/src/main/java/com/example/myapplication/todoDao/TodoDao.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.myapplication.todoDao\r\n\r\nimport androidx.room.Dao\r\nimport androidx.room.Insert\r\nimport androidx.room.OnConflictStrategy\r\nimport androidx.room.Query\r\nimport androidx.room.Update\r\nimport com.example.myapplication.todoEntities.Todo\r\nimport kotlinx.coroutines.flow.Flow\r\n\r\n@Dao\r\ninterface TodoDao {\r\n\r\n    @Insert(onConflict = OnConflictStrategy.IGNORE)\r\n    suspend fun insert(todo: Todo): Long\r\n    @Update\r\n    suspend fun update(todo:Todo)\r\n\r\n    @Query(\"SELECT * FROM \"+ Todo.TABLE_NAME+ \" WHERE isDeleted = false\")\r\n    fun getAllTodos(): Flow<List<Todo>>\r\n\r\n    @Query(\"SELECT * FROM \"+Todo.TABLE_NAME+ \" WHERE date =:currentDate and isDeleted = false\")\r\n    fun getTodosByDate(currentDate: String): Flow<List<Todo>>\r\n\r\n    @Query(\"Update \"+Todo.TABLE_NAME+ \" set isDeleted = true where id = :id\")\r\n    suspend fun delete(id:Long)\r\n\r\n    @Query(\"Delete from \"+Todo.TABLE_NAME+ \" WHERE id = :id\")\r\n    suspend fun deleteFromBin(id:Long)\r\n\r\n    @Query(\"Select * from \"+Todo.TABLE_NAME+ \" WHERE isDeleted = true\")\r\n    fun getDeletedTodos(): Flow<List<Todo>>\r\n\r\n    @Query(\"SELECT * FROM \"+Todo.TABLE_NAME+ \" WHERE isImportant = true and isDeleted = false\")\r\n    fun getImportantTodos(): Flow<List<Todo>>\r\n\r\n    @Query(\"SELECT * FROM \"+Todo.TABLE_NAME+ \" WHERE scheduledDate != :currentDate AND scheduledDate IS NOT NULL AND scheduledDate != 'null'  and isDeleted = false\")\r\n    fun getScheduledTodos(currentDate: String): Flow<List<Todo>>\r\n\r\n    @Query(\"SELECT * FROM \"+Todo.TABLE_NAME+ \" WHERE isFavorite = true\")\r\n    fun getFavoriteTodos(): Flow<List<Todo>>\r\n\r\n    @Query(\"Update \"+Todo.TABLE_NAME+ \" set isFavorite = :isFavourite where id = :id\")\r\n    suspend fun setFavourite(id:Long, isFavourite: Boolean)\r\n\r\n    @Query(\"Update \"+Todo.TABLE_NAME+ \" set isImportant = :isImportant where id = :id\")\r\n    suspend fun setImportant(id:Long, isImportant: Boolean)\r\n\r\n    @Query(\"SELECT * FROM \"+Todo.TABLE_NAME+ \" WHERE isFinished = true\")\r\n    fun getFinishedTodos(): Flow<List<Todo>>\r\n\r\n    @Query(\"Update \"+Todo.TABLE_NAME+ \" set isFinished = :isFinished where id = :id\")\r\n    suspend fun setFinished(id:Long, isFinished: Boolean)\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/myapplication/todoDao/TodoDao.kt b/app/src/main/java/com/example/myapplication/todoDao/TodoDao.kt
--- a/app/src/main/java/com/example/myapplication/todoDao/TodoDao.kt	(revision e4edb1cf4ef2d226e484a9a9995d7c0133a27c8d)
+++ b/app/src/main/java/com/example/myapplication/todoDao/TodoDao.kt	(date 1702046573849)
@@ -16,10 +16,10 @@
     @Update
     suspend fun update(todo:Todo)
 
-    @Query("SELECT * FROM "+ Todo.TABLE_NAME+ " WHERE isDeleted = false")
+    @Query("SELECT * FROM "+ Todo.TABLE_NAME)
     fun getAllTodos(): Flow<List<Todo>>
 
-    @Query("SELECT * FROM "+Todo.TABLE_NAME+ " WHERE date =:currentDate and isDeleted = false")
+    @Query("SELECT * FROM "+Todo.TABLE_NAME+ " WHERE date =:currentDate")
     fun getTodosByDate(currentDate: String): Flow<List<Todo>>
 
     @Query("Update "+Todo.TABLE_NAME+ " set isDeleted = true where id = :id")
Index: app/src/main/java/com/example/myapplication/todoViewModels/TodoViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.myapplication.todoViewModels\r\n\r\nimport android.app.Application\r\nimport androidx.lifecycle.AndroidViewModel\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.example.myapplication.screens.SortOption\r\nimport com.example.myapplication.todoDatabase.TodoDatabase\r\nimport com.example.myapplication.todoEntities.Todo\r\nimport kotlinx.coroutines.CompletableDeferred\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.flow.Flow\r\nimport kotlinx.coroutines.flow.firstOrNull\r\nimport kotlinx.coroutines.flow.map\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.runBlocking\r\nimport java.time.LocalDate\r\nimport java.time.format.DateTimeFormatter\r\n\r\nclass TodoViewModel(app: Application) : AndroidViewModel(app) {\r\n    private val context = getApplication<Application>().applicationContext\r\n    private val dao = TodoDatabase.getDatabase(context).todoDao()\r\n\r\n    val allTodos: Flow<List<Todo>> = dao.getAllTodos()\r\n    val currentDateTodos: Flow<List<Todo>> = dao.getTodosByDate(LocalDate.now().toString())\r\n    val importantTodos: Flow<List<Todo>> = dao.getImportantTodos()\r\n    val scheduledTodos: Flow<List<Todo>> = dao.getScheduledTodos(LocalDate.now().toString())\r\n    val favoriteTodos: Flow<List<Todo>> = dao.getFavoriteTodos()\r\n    val todosInBin: Flow<List<Todo>> = dao.getDeletedTodos()\r\n    val finishedTodos: Flow<List<Todo>> = dao.getFinishedTodos()\r\n\r\n    suspend fun addTodo(todo: Todo): Long {\r\n        val deferred = CompletableDeferred<Long>()\r\n        viewModelScope.launch(Dispatchers.IO) {\r\n            val insertedId = dao.insert(todo = todo)\r\n            deferred.complete(insertedId)\r\n        }\r\n        return deferred.await()\r\n    }\r\n\r\n    fun updateTodo(todo:Todo){\r\n        viewModelScope.launch(Dispatchers.IO){\r\n            dao.update(todo)\r\n        }\r\n    }\r\n\r\n    fun isEmpty(): Boolean = runBlocking{\r\n        val todosList = allTodos.firstOrNull()\r\n        todosList.isNullOrEmpty()\r\n    }\r\n\r\n    fun isImportantEmpty(): Boolean = runBlocking {\r\n        val todosList = importantTodos.firstOrNull()\r\n        todosList.isNullOrEmpty()\r\n    }\r\n\r\n    fun isScheduledEmpty(): Boolean = runBlocking{\r\n        val todosList = scheduledTodos.firstOrNull()\r\n        todosList.isNullOrEmpty()\r\n    }\r\n\r\n    fun setFavourite(todoItemId:Long, isFavClicked:Boolean ) {\r\n        viewModelScope.launch(Dispatchers.IO) {\r\n            try {\r\n                dao.setFavourite(todoItemId, isFavClicked)\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n            }\r\n        }\r\n    }\r\n\r\n    fun setImportant(todoItemId:Long, isImportant:Boolean ) {\r\n        viewModelScope.launch(Dispatchers.IO) {\r\n            try {\r\n                dao.setImportant(todoItemId, isImportant)\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n            }\r\n        }\r\n    }\r\n    fun isFavoritesEmpty(): Boolean = runBlocking{\r\n        val todosList = favoriteTodos.firstOrNull()\r\n        todosList.isNullOrEmpty()\r\n    }\r\n\r\n    suspend fun deleteSelectedTodos(id:Long) {\r\n        dao.delete(id)\r\n    }\r\n\r\n    fun setFinished(todoItemId:Long, isFinished:Boolean ) {\r\n        viewModelScope.launch(Dispatchers.IO) {\r\n            try {\r\n                dao.setFinished(todoItemId, isFinished)\r\n            } catch (e: Exception) {\r\n                e.printStackTrace()\r\n            }\r\n        }\r\n    }\r\n    fun isFinishedEmpty(): Boolean = runBlocking {\r\n        val todosList = finishedTodos.firstOrNull()\r\n        todosList.isNullOrEmpty()\r\n    }\r\n\r\n    fun getSortedTodos(sortOption: SortOption): Flow<List<Todo>>{\r\n        return when (sortOption){\r\n            SortOption.DATE -> allTodos.map { todos -> todos.sortedBy { it.date } }\r\n            SortOption.TITLE -> allTodos.map { todos -> todos.sortedBy { it.title } }\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/myapplication/todoViewModels/TodoViewModel.kt b/app/src/main/java/com/example/myapplication/todoViewModels/TodoViewModel.kt
--- a/app/src/main/java/com/example/myapplication/todoViewModels/TodoViewModel.kt	(revision e4edb1cf4ef2d226e484a9a9995d7c0133a27c8d)
+++ b/app/src/main/java/com/example/myapplication/todoViewModels/TodoViewModel.kt	(date 1702046249916)
@@ -100,6 +100,11 @@
         todosList.isNullOrEmpty()
     }
 
+    fun isTodayEmpty(): Boolean = runBlocking {
+        val todosList = currentDateTodos.firstOrNull()
+        todosList.isNullOrEmpty()
+    }
+
     fun getSortedTodos(sortOption: SortOption): Flow<List<Todo>>{
         return when (sortOption){
             SortOption.DATE -> allTodos.map { todos -> todos.sortedBy { it.date } }
Index: .idea/deploymentTargetDropDown.xml
===================================================================
diff --git a/.idea/deploymentTargetDropDown.xml b/.idea/deploymentTargetDropDown.xml
deleted file mode 100644
--- a/.idea/deploymentTargetDropDown.xml	(revision e4edb1cf4ef2d226e484a9a9995d7c0133a27c8d)
+++ /dev/null	(revision e4edb1cf4ef2d226e484a9a9995d7c0133a27c8d)
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="deploymentTargetDropDown">
-    <targetSelectedWithDropDown>
-      <Target>
-        <type value="QUICK_BOOT_TARGET" />
-        <deviceKey>
-          <Key>
-            <type value="VIRTUAL_DEVICE_PATH" />
-            <value value="C:\Users\wwwip\.android\avd\Pixel_3a_API_34_extension_level_7_x86_64.avd" />
-          </Key>
-        </deviceKey>
-      </Target>
-    </targetSelectedWithDropDown>
-    <timeTargetWasSelectedWithDropDown value="2023-12-06T19:20:05.617863900Z" />
-  </component>
-</project>
\ No newline at end of file
